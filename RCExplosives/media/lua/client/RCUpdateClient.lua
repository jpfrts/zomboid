---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by THeartnet.
--- DateTime: 11/9/2022 11:48
---

if isServer() then return end
require "zCommon"

if not isClient() and not isServer() and not isCoopHost() then
    SINGLEPLAYER = true;
end

local function WeAreInShowRange(x, y, playerX, playerY)
    local answer = false;

    local tX = x;
    local tY = y;

    local showRadius = 120;
    local minX = tX - showRadius;
    local maxX = tX + showRadius;
    local minY = tY - showRadius;
    local maxY = tY + showRadius;

    -- floors_burnt_01_1 - item
    -- floors_burnt_01_0 - burned floor base item

    if playerX >= minX and playerX <= maxX then
        if playerY >= minY and playerY <= maxY then
            answer = true;
        end
    end

    return answer;
end

local function _abs(val)
    local ret = 0;
    if val < 0 then
        ret = -val;
    else
        ret = val;
    end
    return ret;
end

local function _isNegative(val)
    if val < 0 then
        return true;
    else
        return false;
    end
end

local function IsRandomTrue(oneToValue)
    local result = false;

    if not oneToValue or oneToValue <= 0 then
        return result;
    end

    local rand = round(ZombRand(1, oneToValue + 1));
    --print("Rand: "..tostring(rand));
    if (rand == oneToValue) then
        result = true;
    end

    return result;
end

local function hasBaseSupport(square)
    if square:getZ() == 0 then
        return true;
    end

    local baseSquare = getCell():getGridSquare(square:getX(), square:getY(), square:getZ() - 1);

    if not baseSquare then
        return false;
    end

    return baseSquare:hasSupport();
end

local function hasDrillOrNil(squareCheckedList, x, y, z)

    local drilled;
    for k, v in ipairs(squareCheckedList) do
        if  v.x == x and v.y == y and v.z == z then
            drilled = true;
            break;
        end
    end

    return drilled;
end

local function takeAllAfterAll(overallCollection, gatheredCollection, x, y, z)

    local drilledCollection = overallCollection;
    if not drilledCollection then
        drilledCollection = {};
    end

    local perfectlyGatheredCollection = gatheredCollection;
    if not perfectlyGatheredCollection then
        perfectlyGatheredCollection = {};
    end

    local drillingObject = { drilledCollection = drilledCollection,
                             gatheredCollection = perfectlyGatheredCollection };

    local drillSquare = getCell():getGridSquare(x, y, z);
    if not drillSquare then
        -- No square - No Fun
        return drillingObject;
    end

    if not drillSquare:hasFloor(false) then
        return drillingObject;
    end

    if not hasDrillOrNil(drilledCollection, x, y, z) then
        -- take target square if not taken yet
        local newSquareData = { x = x, y = y, z = z };
        table.insert(drilledCollection, newSquareData);
        table.insert(perfectlyGatheredCollection, newSquareData);

        if drillSquare:connectedWithFloor() then
            -- North
            drillingObject = takeAllAfterAll(drilledCollection, perfectlyGatheredCollection, x, y - 1, z);
            -- South
            drillingObject = takeAllAfterAll(drilledCollection, perfectlyGatheredCollection, x, y + 1, z);
            -- West
            drillingObject = takeAllAfterAll(drilledCollection, perfectlyGatheredCollection, x - 1, y, z);
            -- East
            drillingObject = takeAllAfterAll(drilledCollection, perfectlyGatheredCollection, x + 1, y, z);
        end
    end

    return drillingObject;
end

local function drillAllUntilFall(squareCheckedList, x, y, z)
    local checkedList = squareCheckedList;
    if not checkedList then
        checkedList = {};
    end

    local hasStableBasement = false;
    local resultObject;

    if not hasDrillOrNil(checkedList, x, y, z) then
        local drillSquare = getCell():getGridSquare(x, y, z);
        local newSquareData = { x = x, y = y, z = z };
        table.insert(checkedList, newSquareData);

        if not drillSquare then
            -- No square - No Fun
        else
            if drillSquare:connectedWithFloor() then
                if hasBaseSupport(drillSquare) == true then
                    hasStableBasement = true;
                else
                    if hasStableBasement == false then
                        -- North
                        resultObject = drillAllUntilFall(checkedList, x, y - 1, z);
                    end

                    if resultObject.hasStableBasement == false then
                        -- South
                        resultObject = drillAllUntilFall(resultObject.squareCheckedList, x, y + 1, z);
                    end

                    if resultObject.hasStableBasement == false then
                        -- West
                        resultObject = drillAllUntilFall(resultObject.squareCheckedList, x - 1, y, z);
                    end

                    if resultObject.hasStableBasement == false then
                        -- East
                        resultObject = drillAllUntilFall(resultObject.squareCheckedList, x + 1, y, z);
                    end
                end
            else
                hasStableBasement = hasBaseSupport(drillSquare);
            end
        end
    end

    if not resultObject then
        resultObject = { squareCheckedList = checkedList, hasStableBasement = hasStableBasement };
    end

    return resultObject;
end

function RC_EdgeBasedDestruction(square, facing)
    if not square then return end

    local fullDestructionSquare;
    local northSquare_1;
    local northSquare_2;
    local westSquare_1;
    local westSquare_2;
    local attachedNorthSquare_1;
    local attachedNorthSquare_2;
    local attachedWestSquare_1;
    local attachedWestSquare_2;

    if facing == "N" then
        -- Total Destruction
        -- bottomSquare
        fullDestructionSquare = getCell():getGridSquare(square:getX(), square:getY() + 1, square:getZ());

        -- North Facing Attachment Destruction +-
        attachedNorthSquare_1 = getCell():getGridSquare(square:getX(), square:getY() + 1, square:getZ());
        -- West Facing Attachment Destruction +
        attachedWestSquare_1 = getCell():getGridSquare(square:getX() - 1, square:getY(), square:getZ());
        -- West Facing Attachment Destruction
        attachedWestSquare_2 = getCell():getGridSquare(square:getX() - 1, square:getY() + 1, square:getZ());

        -- West Wall Destruction +
        -- rightSquare
        westSquare_1 = getCell():getGridSquare(square:getX() + 1, square:getY(), square:getZ());

        -- West Wall Destruction
        -- bottomEastSquare
        westSquare_2 = getCell():getGridSquare(square:getX(), square:getY() + 1, square:getZ() + 1);

        -- North Wall Destruction
        -- bottomSouthSquare
        northSquare_1 = getCell():getGridSquare(square:getX(), square:getY() + 2, square:getZ());
    end
    if facing == "S" then
        -- Total Destruction
        -- topSquare
        fullDestructionSquare = getCell():getGridSquare(square:getX(), square:getY() - 1, square:getZ());

        -- North Facing Attachment Destruction
        attachedNorthSquare_1 = getCell():getGridSquare(square:getX(), square:getY() - 2, square:getZ());
        -- West Facing Attachment Destruction +
        attachedWestSquare_1 = getCell():getGridSquare(square:getX() - 1, square:getY(), square:getZ());
        -- West Facing Attachment Destruction
        attachedWestSquare_2 = getCell():getGridSquare(square:getX() - 1, square:getY() - 1, square:getZ());

        -- West Wall Destruction +
        -- rightSquare
        westSquare_1 = getCell():getGridSquare(square:getX() + 1, square:getY(), square:getZ());

        -- West Wall Destruction
        -- topEastSquare
        westSquare_2 = getCell():getGridSquare(square:getX() + 1, square:getY() - 1, square:getZ());

        -- North Wall Destruction +-
        -- bottomSquare
        northSquare_1 = getCell():getGridSquare(square:getX(), square:getY() + 1, square:getZ());
    end

    if facing == "W" then
        -- Total Destruction
        -- rightSquare
        fullDestructionSquare = getCell():getGridSquare(square:getX() + 1, square:getY(), square:getZ());

        -- North Facing Attachment Destruction +
        attachedNorthSquare_1 = getCell():getGridSquare(square:getX(), square:getY() - 1, square:getZ());
        -- North Facing Attachment Destruction
        attachedNorthSquare_2 = getCell():getGridSquare(square:getX() + 1, square:getY() - 1, square:getZ());
        -- West Facing Attachment Destruction +-
        attachedWestSquare_1 = getCell():getGridSquare(square:getX() - 1, square:getY(), square:getZ());

        -- West Wall Destruction
        -- rightEastSquare
        westSquare_1 = getCell():getGridSquare(square:getX() + 2, square:getY(), square:getZ());

        -- North Wall Destruction +
        -- bottomSquare
        northSquare_1 = getCell():getGridSquare(square:getX(), square:getY() + 1, square:getZ());

        -- North Wall Destruction
        -- rightSouthSquare
        northSquare_2 = getCell():getGridSquare(square:getX() + 1, square:getY() + 1, square:getZ());
    end
    if facing == "E" then
        -- Total Destruction
        -- leftSquare
        fullDestructionSquare= getCell():getGridSquare(square:getX() - 1, square:getY(), square:getZ());

        -- North Facing Attachment Destruction +
        attachedNorthSquare_1 = getCell():getGridSquare(square:getX(), square:getY() - 1, square:getZ());
        -- North Facing Attachment Destruction
        attachedNorthSquare_2 = getCell():getGridSquare(square:getX() - 1, square:getY() - 1, square:getZ());
        -- West Facing Attachment Destruction
        attachedWestSquare_1 = getCell():getGridSquare(square:getX() - 2, square:getY(), square:getZ());

        -- West Wall Destruction +-
        -- rightSquare
        westSquare_1 = getCell():getGridSquare(square:getX() + 1, square:getY(), square:getZ());

        -- North Wall Destruction +
        -- bottomSquare
        northSquare_1 = getCell():getGridSquare(square:getX(), square:getY() + 1, square:getZ());

        -- North Wall Destruction
        -- leftSouthSquare
        northSquare_2 = getCell():getGridSquare(square:getX() - 1, square:getY() + 1, square:getZ());
    end

    if westSquare_1 then
        if ((facing == "N") or (facing == "S")) then
            RC_MoveAbleDestruction(westSquare_1, westSquare_1, "E");
        end

        if (facing == "E") then
            RC_MoveAbleDestruction(westSquare_1, westSquare_1, "E");
        end
        RC_EdgeDestruction(westSquare_1, false);
    end
    if westSquare_2 then
        RC_EdgeDestruction(westSquare_2, false);
    end
    if northSquare_1 then
        if ((facing == "E") or (facing == "W")) then
            RC_MoveAbleDestruction(northSquare_1, northSquare_1, "S");
        end

        if (facing == "S") then
            RC_MoveAbleDestruction(northSquare_1, northSquare_1, "S");
        end
        RC_EdgeDestruction(northSquare_1, true);
    end
    if northSquare_2 then
        RC_EdgeDestruction(northSquare_2, true);
    end

    if attachedWestSquare_1 then
        if ((facing == "N") or (facing == "S")) then
            RC_MoveAbleDestruction(square, attachedWestSquare_1, "W");
        end

        if (facing == "W") then
            RC_MoveAbleDestruction(square, attachedWestSquare_1, "W");
        end
        RC_AttachedDestruction(attachedWestSquare_1, false);
    end
    if attachedWestSquare_2 then
        RC_AttachedDestruction(attachedWestSquare_2, false);
    end
    if attachedNorthSquare_1 then
        if ((facing == "E") or (facing == "W")) then
            RC_MoveAbleDestruction(square, attachedNorthSquare_1, "N");
        end

        if (facing == "N") then
            RC_MoveAbleDestruction(square, attachedNorthSquare_1, "N");
        end
        RC_AttachedDestruction(attachedNorthSquare_1, true);
    end
    if attachedNorthSquare_2 then
        RC_AttachedDestruction(attachedNorthSquare_2, true);
    end

    RC_ClearDestruction(square);
    RC_Incineration(square);

    if fullDestructionSquare then
        local oppositeSquare = fullDestructionSquare;
        RC_ClearDestruction(oppositeSquare);
        RC_Incineration(oppositeSquare);
    end

    return fullDestructionSquare;
end

function RC_EdgeDestruction(square, north)

    if not square then return end;

    local objectGraveList = {};
    local objectGraveShiftedList = {};
    local worldObjects = square:getObjects();
    local specialObjects = square:getSpecialObjects();

    if specialObjects:size() > 0 then
        for i = 0, specialObjects:size() - 1, 1 do
            local specialObj = specialObjects:get(i);
            local props = specialObj:getProperties();
            if props then
                local facing = props:Is("Facing") and props:Val("Facing") or nil;
                if facing then
                    --print("Special Facing: "..tostring(facing));
                    if (tostring(facing) == "S" and north == true) then
                        table.insert(objectGraveList, specialObj);
                    end

                    if (tostring(facing) == "E" and north == false) then
                        table.insert(objectGraveList, specialObj);
                    end
                end
            end
        end
    end

    if worldObjects and not worldObjects:isEmpty() then
        local objs_size = worldObjects:size();
        if objs_size > 0 then
            for i = 0, objs_size - 1, 1 do
                local obj = worldObjects:get(i);
                local props = obj:getProperties();

                -- Windows Frames
                if IsoWindowFrame.isWindowFrame(obj, north) then
                    table.insert(objectGraveList, obj);
                end

                -- Glass Windows
                if instanceof(obj, "IsoWindow") then
                    if (obj:getNorth() == north) then
                        table.insert(objectGraveList, obj);
                    end
                end

                if props then
                    local facing = props:Is("Facing") and props:Val("Facing") or nil;

                    -- Solid Walls
                    if (tostring(obj:getType()) == "wall") then
                        if props then
                            if (props:Is("WallN") and north == true) then
                                table.insert(objectGraveList, obj);
                            end

                            if (props:Is("WallW") and north == false) then
                                table.insert(objectGraveList, obj);
                            end

                            if props:Is("WallNW") then
                                table.insert(objectGraveList, obj);
                            end
                        end
                    end

                    -- Door Frames
                    if (props:Is("DoorWallN") and north == true) then
                        table.insert(objectGraveList, obj);
                    end
                    if (props:Is("DoorWallW") and north == false) then
                        table.insert(objectGraveList, obj);
                    end

                    -- Wall Based Electric Lamps/Switches
                    if facing then
                        if ((tostring(facing) == "N") and (north == false)) then
                            table.insert(objectGraveList, obj);
                        end

                        if ((tostring(facing) == "E") and (north == false)) then
                            table.insert(objectGraveList, obj);
                        end
                    end
                end

                -- Doors Variations
                if (instanceof(obj, "IsoDoor") or (instanceof(obj, "IsoThumpable") and obj:isDoor())) then
                    local graveAble = false;

                    if (obj:getNorth() == north) then
                        -- Garage Doors
                        local garageDoorObjects = buildUtil.getGarageDoorObjects(obj);
                        for n=1,#garageDoorObjects do
                            --print("Garage Door Part to be destroyed: "..tostring(garageDoorObjects[n]:getType()));
                            table.insert(objectGraveShiftedList, garageDoorObjects[n]);
                            graveAble = true;
                        end

                        -- Double Doors
                        local doubleDoorObjects = buildUtil.getDoubleDoorObjects(obj)
                        for n=1,#doubleDoorObjects do
                            table.insert(objectGraveShiftedList, doubleDoorObjects[n]);
                            graveAble = true;
                        end

                        -- Normal Doors
                        if graveAble == false then
                            table.insert(objectGraveList, obj);
                        end
                    end
                end
            end
        end
    end

    -- Removing All Selected Objects From a Square
    for k, v in ipairs(objectGraveList) do
        if v then
            square:transmitRemoveItemFromSquare(v);
        end
    end

    -- Removing All Large Doors Objects in Adjacent Squares
    for k, v in ipairs(objectGraveShiftedList) do
        if v then
            local shiftedSquare = v:getSquare();
            if shiftedSquare then
                shiftedSquare:transmitRemoveItemFromSquare(v);
            end
        end
    end
end

function RC_AttachedDestruction(square, north)
    if not square then return end

    local objectGraveList = {};
    local worldObjects = square:getObjects();
    local specialObjects = square:getSpecialObjects();

    if specialObjects:size() > 0 then
        for i = 0, specialObjects:size() - 1, 1 do
            local specialObj = specialObjects:get(i);
            local props = specialObj:getProperties();
            if props then
                local facing = props:Is("Facing") and props:Val("Facing") or nil;
                local isHigh = props:Is("IsHigh");
                if facing and isHigh then
                    if (tostring(facing) == "N" and north == true) then
                        table.insert(objectGraveList, specialObj);
                    end

                    if (tostring(facing) == "W" and north == false) then
                        table.insert(objectGraveList, specialObj);
                    end
                end
            end
        end
    end

    if worldObjects and not worldObjects:isEmpty() then
        local objs_size = worldObjects:size();

        if objs_size > 0 then
            for i = 0, objs_size - 1, 1 do
                local obj = worldObjects:get(i);
                local props = obj:getProperties();

                if props then
                    local facing = props:Is("Facing") and props:Val("Facing") or nil;
                    local isHigh = props:Is("IsHigh");
                    if facing and isHigh then
                        if (tostring(facing) == "N" and north == true) then
                            table.insert(objectGraveList, obj);
                        end

                        if (tostring(facing) == "W" and north == false) then
                            table.insert(objectGraveList, obj);
                        end
                    end
                end
            end
        end
    end

    -- Removing All Selected Objects From a Square
    for k, v in ipairs(objectGraveList) do
        if v then
            square:transmitRemoveItemFromSquare(v);
        end
    end
end

function RC_MoveAbleDestruction(protectiveSquare, vulnerableSquare, facing)
    if not protectiveSquare then return end
    if not vulnerableSquare then return end

    local objectGraveList = {};
    local protectiveWorldObjects = protectiveSquare:getObjects();

    local protected = false;
    if protectiveWorldObjects and not protectiveWorldObjects:isEmpty() then
        local objs_size = protectiveWorldObjects:size();

        if objs_size > 0 then
            for i = 0, objs_size - 1, 1 do
                local obj = protectiveWorldObjects:get(i);
                local props = obj:getProperties();

                if props then
                    if (tostring(obj:getType()) == "wall") then
                        --local objFacing = props:Is("Facing") and props:Val("Facing") or nil;
                        if (facing == "E" or facing == "W") and (props:Is("WallW") or props:Is("WallNW")) then
                            --print("Face: "..tostring(facing).." - protected");
                            protected = true;
                            break;
                        end

                        if (facing == "N" or facing == "S") and (props:Is("WallN") or props:Is("WallNW")) then
                            --print("Face: "..tostring(facing).." - protected");
                            protected = true;
                            break;
                        end
                    end
                end
            end
        end
    end

    if protected == false then
        local vulnerableWorldObjects = vulnerableSquare:getObjects();
        if vulnerableWorldObjects and not vulnerableWorldObjects:isEmpty() then
            local objs_size = vulnerableWorldObjects:size();
            for i = 0, objs_size - 1, 1 do
                local obj = vulnerableWorldObjects:get(i);
                local props = obj:getProperties();

                if props then
                    if props:Is("IsMoveAble") and not props:Is("FootstepMaterial") then
                        table.insert(objectGraveList, obj);
                    end
                end
            end

            -- Removing All Selected Objects From a Square
            for k, v in ipairs(objectGraveList) do
                if v then
                    vulnerableSquare:transmitRemoveItemFromSquare(v);
                end
            end
        end
    end
end

function RC_FlightCrew(epiX, epiY, epiZ, blastRadius, blastFloorZData)
    local currentPlayer = getPlayer();
    local executionerId = currentPlayer:getOnlineID();

    local flightData = { epiX = epiX, epiY = epiY, epiZ = epiZ,
                         blastRadius = blastRadius, blastFloorZData = blastFloorZData,
                         executionerId = executionerId };

    --print("Initiating TakeOff at epiX: "..tostring(flightData.epiX)..", epiY: "..tostring(flightData.epiY)..", epiZ: "..tostring(flightData.epiZ)..
    --        ", blastRadius: "..tostring(flightData.blastRadius)..", blastFloorZData: "..tostring(blastFloorZData)..
    --        ", executionerId: "..tostring(executionerId));
    sendClientCommand("RC_Explosion", "TakeOff", flightData);
end

function RC_BlastWave(epiSquare, blastRadius)
    local blastWaveRadius = blastRadius * 2.5;
    local windows = getCell():getWindowList();

    for i=0, windows:size() - 1, 1 do
        local window = windows:get(i);
        if window then
            local distance = RC_GetDistanceBetweenSqrt(epiSquare, window);
            if(distance <= blastWaveRadius) and (instanceof(window,"IsoWindow")) then
                window:smashWindow();
            end
        end
    end
end

function RC_Adaptation(square)
    local floorObj = square:getFloor()
    if floorObj == nil then
        local burnedFloor =  IsoObject.new(square, "floors_burnt_01_0", false);
        square:AddSpecialObject(burnedFloor);
        if isClient() then burnedFloor:transmitCompleteItemToServer() end
    else
        floorObj:AttachExistingAnim(getSprite("floors_burnt_01_1"), 0, 0, false, 0, false, 0)
        if isClient() then floorObj:transmitUpdatedSpriteToServer(); end
    end
end

function RC_Incineration(square)
    local burnedFloor = IsoObject.new(square, "floors_burnt_01_0", false);
    square:AddSpecialObject(burnedFloor);

    if isClient() then burnedFloor:transmitCompleteItemToServer() end
end

function RC_Annihilation(square)
    if not square then return end

    local worldObjFound = true;
    local objectGraveList = {};
    local worldObjects = square:getObjects();
    local specialObjects = square:getSpecialObjects();

    if specialObjects:size() > 0 then
        for i = 0, specialObjects:size() - 1, 1 do
            local specialObj = specialObjects:get(i);
            table.insert(objectGraveList, specialObj);
            local props = specialObj:getProperties();
            local sprite = specialObj:getSprite();
            if props then
                if not props:Is("FootstepMaterial") then
                    if sprite then
                        if (sprite:getName() ~= "floors_burnt_01_0") then
                            worldObjFound = true;
                        end
                    else
                        worldObjFound = true;
                    end
                end
            end
        end
    end

    if worldObjects and not worldObjects:isEmpty() then
        local objs_size = worldObjects:size();
        if objs_size > 0 then
            for i = 0, objs_size - 1, 1 do
                local obj = worldObjects:get(i);
                table.insert(objectGraveList, obj);
                local props = obj:getProperties();
                local sprite = obj:getSprite();
                if props then
                    --local facing = props:Is("Facing") and props:Val("Facing") or nil;
                    if not props:Is("FootstepMaterial") then
                        if sprite then
                            if (sprite:getName() ~= "floors_burnt_01_0") then
                                worldObjFound = true;
                            end
                        else
                            worldObjFound = true;
                        end
                    end
                end
            end
        end
    end

    local vehicle = square:getVehicleContainer();
    if vehicle then
        --print("Trying to remove vehicle: "..tostring(vehicle:getId()));
        local wreckData = { x = square:getX(), y = square:getY(), z = square:getZ() };
        sendClientCommand("RC_Explosion", "WreckIt", wreckData);
    end

    -- Removing All Selected Objects From a Square
    for k, v in ipairs(objectGraveList) do
        if v then
            square:transmitRemoveItemFromSquare(v);
        end
    end

    return worldObjFound;
end

function RC_HasWall(square)
    if not square then return false end;
    if square:getWall(true) then return true end;
    if square:getWall(false) then return true end;
    return false;
end

function RC_ClearDestruction(square)
    if not square then return end

    local objectGraveList = {};
    local objectGraveShiftedList = {};
    local worldObjects = square:getObjects();
    local specialObjects = square:getSpecialObjects();

    if specialObjects:size() > 0 then
        for i = 0, specialObjects:size() - 1, 1 do
            local specialObj = specialObjects:get(i);
            local props = specialObj:getProperties();
            if props then
                --local facing = props:Is("Facing") and props:Val("Facing") or nil;
                if not props:Is("FootstepMaterial") then
                    --print("SpeCObj Not FootstepMaterial: "..tostring(specialObj:getSprite():getName()));
                    table.insert(objectGraveList, specialObj);
                end
            end
        end
    end

    if worldObjects and not worldObjects:isEmpty() then
        local objs_size = worldObjects:size();
        if objs_size > 0 then
            for i = 0, objs_size - 1, 1 do
                local obj = worldObjects:get(i);
                local props = obj:getProperties();

                -- Windows Frames
                if IsoWindowFrame.isWindowFrame(obj) then
                    --print("Window frame: "..tostring(obj:getSprite():getName()));
                    table.insert(objectGraveList, obj);
                end

                -- Glass Windows
                if instanceof(obj, "IsoWindow") then
                    --print("Window: "..tostring(obj:getSprite():getName()));
                    table.insert(objectGraveList, obj);
                end

                -- Solid Walls
                if (tostring(obj:getType()) == "wall") then
                    --print("Type wall: "..tostring(obj:getSprite():getName()));
                    table.insert(objectGraveList, obj);
                end

                -- Door Frames / All what is not the floor - floor will be burned
                if props then
                    --local facing = props:Is("Facing") and props:Val("Facing") or nil;

                    if not props:Is("FootstepMaterial") then
                        --print("Obj Not FootstepMaterial: "..tostring(obj:getSprite():getName()));
                        table.insert(objectGraveList, obj);
                    end
                end

                -- Doors Variations
                if (instanceof(obj, "IsoDoor") or (instanceof(obj, "IsoThumpable") and obj:isDoor())) then
                    local graveAble = false;

                    -- Garage Doors
                    local garageDoorObjects = buildUtil.getGarageDoorObjects(obj);
                    for n=1,#garageDoorObjects do
                        --print("Garage Door Part to be destroyed: "..tostring(garageDoorObjects[n]:getType()));
                        table.insert(objectGraveShiftedList, garageDoorObjects[n]);
                        graveAble = true;
                    end

                    -- Double Doors
                    local doubleDoorObjects = buildUtil.getDoubleDoorObjects(obj)
                    for n=1,#doubleDoorObjects do
                        table.insert(objectGraveShiftedList, doubleDoorObjects[n]);
                        graveAble = true;
                        for k, v in ipairs(objectGraveList) do
                            if v then
                                --print("First cleaning destruction: "..tostring(v:getSprite():getName()));
                                square:transmitRemoveItemFromSquare(v);
                            end
                        end
                    end

                    -- Normal Doors
                    if graveAble == false then
                        --print("Graveable: "..tostring(obj:getSprite():getName()));
                        table.insert(objectGraveList, obj);
                    end
                end
            end
        end
    end

    -- Removing All Selected Objects From a Square
    for k, v in ipairs(objectGraveList) do
        if v then
            square:transmitRemoveItemFromSquare(v);
        end
    end

    -- Removing All Large Doors Objects in Adjacent Squares
    for k, v in ipairs(objectGraveShiftedList) do
        if v then
            local shiftedSquare = v:getSquare();
            if shiftedSquare then
                --print("Second clear destruction: "..tostring(v:getSprite():getName()));
                shiftedSquare:transmitRemoveItemFromSquare(v);
            end
        end
    end
end

function RC_MakeThemFillThePainAt(square, flatPain, blackHole)
    if not square then return end
    if not flatPain or flatPain <= 0 then return end
    --print("Let's start the suffering!");

    local sufferingData = {};
    local potentialTargets = 0;
    local painShouldBeDelivered;

    if SINGLEPLAYER then
        -- Singleplayer
        potentialTargets = square:getMovingObjects();

        for i=0, potentialTargets:size() - 1, 1 do
            local tTarget = potentialTargets:get(i);
            if instanceof(tTarget, "IsoGameCharacter") then
                if tTarget:isDead() == false then
                    local characterType;
                    local ssObject;
                    if tTarget:isZombie() then
                        --print("IsoZombie Detected");
                        characterType = "IsoZombie";
                    else
                        if instanceof(tTarget, "IsoPlayer") then
                            --print("Recognized as IsoPlayer: "..tostring(tTarget:getUsername()));
                                characterType = "IsoPlayer";
                                ssObject = tTarget;
                        else
                            if instanceof(tTarget, "IsoSurvivor") then
                                --print("Recognized as IsoSurvivor");
                                characterType = "IsoSurvivor";
                            end
                        end
                    end

                    if not characterType then
                        characterType = "IsoGameCharacter";
                    end

                    if (characterType == "IsoZombie") and (blackHole == true) then
                        -- Zombies will take a flight in the next special step
                        --print("Alien Detected: "..tostring(characterType));
                    else
                        --print("Target Detected: "..tostring(characterType));
                        local targetId = tTarget:getID();
                        local sufferingEntity = { zId = targetId, targetType = characterType, flatPain = flatPain, ssObject = ssObject };

                        table.insert(sufferingData, sufferingEntity);
                        painShouldBeDelivered = true;
                    end
                end
            end
        end
    else
        -- Multiplayer
        local zCell = square:getCell();
        local zList = zCell:getZombieList();

        for i=0, zList:size()-1, 1 do
            local zZombie = zList:get(i);
            if (zZombie:isDead() == false) and (blackHole == false) then
                -- Zombies will take a flight in the next special step
                local zSquare = zZombie:getSquare();
                if zSquare then
                    if zSquare:getID() == square:getID() then
                        local targetId = zZombie:getOnlineID();
                        local sufferingEntity = { zId = targetId, targetType = "IsoZombie", flatPain = flatPain };
                        table.insert(sufferingData, sufferingEntity);
                        painShouldBeDelivered = true;
                        potentialTargets = potentialTargets + 1;
                    end
                end
            end
        end

        local pList = zCommon:getOnlinePlayers();
        for i=0, pList:size()-1, 1 do
            local pPlayer = pList:get(i);
            if pPlayer:isAlive() then
                local pSquare = pPlayer:getSquare();
                if pSquare and square then
                    if pSquare:getID() == square:getID() then
                        local targetId = pPlayer:getOnlineID();
                        local sufferingEntity = { zId = targetId, targetType = "IsoPlayer", flatPain = flatPain};
                        table.insert(sufferingData, sufferingEntity);
                        painShouldBeDelivered = true;

                        potentialTargets = potentialTargets + 1;
                    end
                end
            end
        end

        local sList = zCell:getSurvivorList();
        for i=0, sList:size()-1, 1 do
            local sSurvivor = sList:get(i);
            if sSurvivor:isAlive() then
                local sSquare = sSurvivor:getSquare();
                if sSquare:getID() == square:getID() then
                    local targetId = sSurvivor:getUID();
                    local sufferingEntity = { zId = targetId, targetType = "IsoSurvivor", flatPain = flatPain };
                    table.insert(sufferingData, sufferingEntity);
                    painShouldBeDelivered = true;

                    potentialTargets = potentialTargets + 1;
                end
            end
        end
        --print("Potential targets: "..tostring(potentialTargets));
    end

    if painShouldBeDelivered then
        --print("Pain should be delivered");
        local zNeo = getPlayer();
        local executionData = { x = square:getX(), y = square:getY(), z = square:getZ(),
                                zData = sufferingData, executionerId = zNeo:getOnlineID() };

        --for k, v in ipairs(executionData.zData) do
        --    print("CharacterType: "..tostring(v.characterType)..", ssObject: "..tostring(v.ssObject));
        --end

        if SINGLEPLAYER then
            RC_OnPainDelivery("RC_Explosion", "PainDelivery", executionData);
        else
            sendClientCommand("RDC_Z", "PainRetransmission", executionData);
        end
    end
end

function RC_GetDistanceBetweenSqrt(square, zombie)
    if(square == nil) or (zombie == nil) then
        return -1
    end

    local z1x = square:getX() + 0.5;
    local z1y = square:getY() + 0.5;
    local z2x = zombie:getX();
    local z2y = zombie:getY();
    local result = math.sqrt((z1x-(z2x)) * (z1x-(z2x))  +  (z1y-(z2y)) * (z1y-(z2y)));
    return result;
end

function RC_GetLanding(zombie, ticksToFall, flySpeedX, flySpeedY)
    if not zombie then return nil end
    local landingSquare;

    local zX = zombie:getX();
    local zY = zombie:getY();

    local destX = zX;
    local destY = zY;

    for i=0, ticksToFall, 1 do
        destX = destX + flySpeedX;
        destY = destY + flySpeedY;
    end

    -- pointing our perfect landing to ground level 0
    landingSquare = getCell():getGridSquare(destX, destY, 0);
    if not landingSquare then
        --print("Landing Square x: "..tostring(destX)..", y: "..tostring(destY)..", z: "..tostring(0).." not found");
        landingSquare = getCell():getGridSquare(zX, zY, zombie:getZ());
        --print("Alternative Landing Square x: "..tostring(landingSquare:getX())..", y: "..tostring(landingSquare:getY())..", z: "..tostring(landingSquare:getZ()));
    end

    --print("Potential Landing x: "..tostring(landingSquare:getX())..", y: "..tostring(landingSquare:getY())..", z: "..tostring(landingSquare:getZ()));
    return landingSquare;
end

function RC_CollectPassengerData(epiX, epiY, epiZ, blastFloorZData, executionerId)

    local flightData = {};
    local flightPacific7500 = {};
    local epiSquare = getCell():getOrCreateGridSquare(epiX, epiY, epiZ);
    flightPacific7500 = epiSquare:getCell():getZombieList();
    local flightRegulator = 40;
    local rcGravity = 0.025;

    if flightPacific7500 then
        --print("Boarding for Flight Pacific 7500, awaited passengers: "..tostring(flightPacific7500:size()));
        for i = 0, flightPacific7500:size()-1, 1 do
            local zPassenger = flightPacific7500:get(i);
            for _, zone in ipairs(blastFloorZData) do
                --print("zone.zLevel: "..tostring(zone.zLevel)..", zPassenger:getZ(): "..tostring(zPassenger:getZ()));
                if zone.zLevel == zPassenger:getZ() then
                    local distance = RC_GetDistanceBetweenSqrt(epiSquare, zPassenger);
                    --print("zone.blastRadius: "..tostring(zone.blastRadius)..", distance: "..tostring(distance));
                    if (distance <= (zone.blastRadius - 1)) then    -- - 1 minimum burn area with direct damage
                        local onlineId;
                        if SINGLEPLAYER then
                            onlineId = zPassenger:getID();
                        else
                            onlineId = zPassenger:getOnlineID();
                        end
                        --print("Passengers OnlineID: "..tostring(onlineId));

                        local zLevel = zone.zLevel;
                        local flyRadius = zone.blastRadius * 2;
                        local xDiff = epiSquare:getX() + 0.5 - zPassenger:getX();    -- value passed for x per distance between epiX and zombieX
                        local yDiff = epiSquare:getY() + 0.5 - zPassenger:getY();    -- value passed for y per distance between epiY and zombieY
                        local flySpeedX = 0;
                        local flySpeedY = 0;
                        local zv = 0;
                        local ticksToFall = 1;
                        local fX;
                        local fY;
                        local fZ;

                        if epiZ <= zLevel then
                            zv = ((flyRadius-distance)*1.1)/flightRegulator;
                        else
                            -- no one will fly if the detonation happened just above
                            zv = rcGravity;
                        end

                        --print("ZV: "..tostring(zv));
                        for i=zv, 0, - rcGravity do
                            ticksToFall = ticksToFall + 1;
                        end
                        --print("Initially ticks to fall: "..tostring(ticksToFall));


                        if distance < 1 then
                            distance = 1;
                        end

                        local radiusXDiff = (flyRadius * xDiff)/distance; -- value passed for x per explosion radius from epiX
                        local radiusYDiff = (flyRadius * yDiff)/distance; -- value passed for y per explosion radius from epiY

                        if(xDiff < 0) then
                            flySpeedX = (((zCommon._abs(radiusXDiff)-(xDiff))*1.5)/flightRegulator);   -- value passed per tick for x
                        else
                            flySpeedX = (((-zCommon._abs(radiusXDiff)-xDiff)*1.5)/flightRegulator);
                        end

                        if(yDiff < 0) then
                            flySpeedY = (((zCommon._abs(radiusYDiff)-(yDiff))*1.5)/flightRegulator);   -- value passed per tick for y
                        else
                            flySpeedY = (((-zCommon._abs(radiusYDiff)-yDiff)*1.5)/flightRegulator) ;
                        end

                        local potentialLanding = RC_GetLanding(zPassenger, ticksToFall, flySpeedX, flySpeedY);
                        local finalLanding = RC_GetFarOpenSquare(zPassenger, potentialLanding, ticksToFall, flySpeedX, flySpeedY);
                        local finalTicksToFall;

                        if finalLanding then
                            fX = finalLanding.landingX;
                            fY = finalLanding.landingY;
                            fZ = finalLanding.landingZ;
                            finalTicksToFall = finalLanding.finalTicksToFall;
                        else
                            -- should not happen, but.
                            --print("Missing final landing, black hole activated");
                            fX = epiSquare:getX()
                            fY = epiSquare:getY()
                            fZ = zLevel;
                            finalTicksToFall = 1;
                        end

                        local higherAltitude
                        local fallGravitySuppression = 0.6;
                        if zLevel > 0 then
                            higherAltitude = zLevel + zv + fallGravitySuppression;
                        else
                            higherAltitude = zLevel + zv;
                        end

                        local rcXn = zPassenger:getX();
                        local rcYn = zPassenger:getY();

                        local landingSquare = getCell():getGridSquare(fX, fY, fZ);
                        if landingSquare then
                            local finalDistance = RC_GetDistanceBetweenSqrt(epiSquare, landingSquare);
                            if (finalDistance <= (zone.blastRadius - 1)) then
                                -- didn't left a black hole area - means going zero base down
                                fZ = 0;
                            end
                        end

                        local passengerFlightData = { onlineId = onlineId, kiraId = executionerId, zLevel = zLevel,
                                                        rcXn = rcXn, rcYn = rcYn,
                                                        flySpeedX = flySpeedX, flySpeedY = flySpeedY, ticksToFall = finalTicksToFall,
                                                        fX = fX, fY = fY, fZ = fZ, higherAltitude = higherAltitude };

                        --print("Boarding... onlineId: "..tostring(onlineId)..", kiraId: "..tostring(executionerId)..", zLevel: "..tostring(zLevel)..
                        --        ", rcXn: "..tostring(rcXn)..", rcYn: "..tostring(rcYn)..
                        --        ", flySpeedX: "..tostring(flySpeedX)..", flySpeedY: "..tostring(flySpeedY)..", ticksToFall: "..tostring(finalTicksToFall)..
                        --        ", fX: "..tostring(fX)..", fY: "..tostring(fY)..", fZ: "..tostring(fZ)..", higherAltitude: "..tostring(higherAltitude));

                        table.insert(flightData, passengerFlightData);
                        break;
                    end
                end
            end
        end
    end

    return flightData;
end

function RC_GetFarOpenSquare(zombie, potentialLanding, ticksToFall, flySpeedX, flySpeedY)
    local finalLanding;
    if not zombie then
        --print("No passenger, returning: "..tostring(finalLanding));
        return finalLanding;
    end
    if not potentialLanding then
        --print("No potentialLanding, returning: "..tostring(zombie));
        return zombie;
    end;

    local zombieX = zombie:getX();
    local zombieY = zombie:getY();

    local zombieZ = zombie:getZ();    -- if it already started to fall by PZ default gravity
    --print("Getting Initial Zombie X: "..tostring(zombieX)..", Y: "..tostring(zombieY)..", Z: "..tostring(zombieZ));

    local landingX = potentialLanding:getX();
    local landingY = potentialLanding:getY();
    local landingZ = potentialLanding:getZ();   -- pointing at level zero

    local finalTicksToFall = ticksToFall;
    for  i=ticksToFall, 0, -1 do
        --print("Landing X: "..tostring(landingX)..", Y: "..tostring(landingY)..", Z: "..tostring(landingZ));
        local squareTo = getCell():getGridSquare(landingX, landingY, landingZ);

        finalTicksToFall = i;
        --print("Zombie Cell: "..tostring(zombie:getCell()));
        --print("World Cell: "..tostring(getCell()));
        if squareTo then
            -- even if we plan to land to the ground level 0, we still looking by a straight line to fly by it - zombieZ
            local LOSTestResults = LosUtil.lineClear(getCell(), zombieX, zombieY, zombieZ, landingX, landingY, zombieZ, false);
            local tLOS = tostring(LOSTestResults);
            --print("tLOS: "..tostring(tLOS));
            if tLOS == "Clear" or tLOS == "ClearThroughOpenDoor" or tLOS == "ClearThroughWindow" then
                finalLanding = { landingX = landingX, landingY = landingY, landingZ = landingZ, finalTicksToFall = finalTicksToFall };
                break;
            end
        end

        landingX = landingX - flySpeedX;
        landingY = landingY - flySpeedY;
    end

    if finalLanding then
        for i=zombieZ, 0, -1 do
            local squareFlyBy = getCell():getGridSquare(landingX, landingY, i);
            if squareFlyBy then
                if squareFlyBy:hasFloor(false) == true then
                    finalLanding.landingZ = i;
                    break;
                end
            end
        end

        --print("LandingZ confirmed: "..tostring(finalLanding.landingZ));
    else
        --print("Final Landing is null for: "..tostring(zombie));
    end

    return finalLanding;
end

function RC_OnDemolitionInitiated(module, command, destructionData)
    if module ~= "RC_Explosion" then return end
    if command ~= "DemolitionInitiated" then return end

    --print("Accepting DemolitionData");

    local executionerId = getPlayer():getOnlineID();
    local flightData = RC_CollectPassengerData(destructionData.epiX , destructionData.epiY, destructionData.epiZ,
                                                destructionData.blastFloorZData, executionerId)
    if flightData then
        local flightDataObject = { flightData = flightData, kiraId = executionerId,
                                   epiX = destructionData.epiX, epiY = destructionData.epiY };
        if SINGLEPLAYER then
            On_TakeOff("RC_Explosion", "TakeOff", nil, flightDataObject);
        else
            sendClientCommand("RC_Explosion", "TakeOff", flightDataObject);
        end
    end

    local baseDamage = SandboxVars.RC.ExplosiveBaseDamage;
    local flatDamage = baseDamage * destructionData.unleashedEnergy;
    --print("Base Damage: "..tostring(baseDamage)..", UnleashedEnergy: "..tostring(destructionData.unleashedEnergy)..", flatDamage: "..tostring(flatDamage));

    for k, v in ipairs(destructionData.tabledCords) do
        if v then
            --print("To be exploded x: "..tostring(v.exX)..", y: "..tostring(v.exY)..", z: "..tostring(v.exZ)..
            --        ", radius: "..tostring(v.radius)..", isBlackHole: "..tostring(v.blackHole));
            local demolishedSquare =  getCell():getGridSquare(v.exX, v.exY, v.exZ);
            if demolishedSquare then
                if (v.blackHole == true) then
                    local worldObjFound = RC_Annihilation(demolishedSquare);
                    if v.exZ == 0 then
                        RC_Incineration(demolishedSquare);

                        if worldObjFound == true then
                            if (IsRandomTrue(2)) then
                                RC_Adaptation(demolishedSquare);
                            end
                        end
                    end
                else
                    local burnData = { x = v.exX, y = v.exY, z = v.exZ };
                    sendClientCommand("RC_Explosion", "BurnItDown", burnData);
                end

                RC_MakeThemFillThePainAt(demolishedSquare, flatDamage, v.blackHole);
            end
        end
    end

    local epiCenterSquare = getCell():getGridSquare(destructionData.epiX , destructionData.epiY, 0);
    RC_BlastWave(epiCenterSquare,  destructionData.blastRadius);
end

function RC_OnDestructionInitiated(module, command, destructionData)
    if module ~= "RC_Explosion" then return end
    if command ~= "DestructionInitiated" then return end

    local destrX = destructionData.x;
    local destrY = destructionData.y;
    local destrZ = destructionData.z;
    local smokeData = nil;

    local destructionSquare = getCell():getGridSquare(destrX, destrY, destrZ);
    local facing = destructionData.facing;
    local explosionSplashRadius = destructionData.explosionSplashRadius;
    local explosionSectionCount = destructionData.explosionSectionCount;
    local explosionDamage = destructionData.explosionDamage;

    local oneSectionDamage = explosionDamage / explosionSectionCount;
    local oneSectionRadius = explosionSplashRadius / explosionSectionCount;

    if not destructionSquare then
        --print("Destruction is passing by...");
        return;
    end

    for xX = (-1)*(explosionSplashRadius - 1) , explosionSplashRadius - 1, 1 do
        for yY = (-1)*(explosionSplashRadius - 1), explosionSplashRadius - 1, 1 do
            for i = 0, explosionSectionCount - 1, 1 do
                local currentSectionDamage;
                if ((zCommon._abs(xX) <= oneSectionRadius * i) and (zCommon._abs(yY) <= oneSectionRadius * i)) then
                    currentSectionDamage = explosionDamage - (oneSectionDamage * i);

                    -- APPLY DAMAGE AT COORDINATE
                    local tX = destrX + xX;
                    local tY = destrY + yY;
                    local affectedSquare = getCell():getGridSquare(tX, tY, destrZ);
                    if affectedSquare then
                        local LOSTestResults = LosUtil.lineClear(getCell(), tX, tY, destrZ, destrX, destrY, destrZ, false);
                        local tLOS = tostring(LOSTestResults);
                        if tLOS == "Clear" or tLOS == "ClearThroughOpenDoor" or tLOS == "ClearThroughWindow" then

                            -- APPLY RANGE BASED DECAYED DAMAGE
                            RC_MakeThemFillThePainAt(affectedSquare, currentSectionDamage, false);

                            smokeData = { x = tX, y = tY, z = destrZ };
                            sendClientCommand("RC_Explosion", "SmokesUp", smokeData);
                            --print("DIRECT HIT by "..tostring(currentSectionDamage));
                        end
                    end
                    -- BRAKE DUE TO IT IS ADDITIONAL SECTION SELECTION LOOP
                    break;
                end
            end
        end
    end

    local oppositeSquare = RC_EdgeBasedDestruction(destructionSquare, facing);

    if oppositeSquare then

        -- APPLY FULL DAMAGE
        RC_MakeThemFillThePainAt(oppositeSquare, explosionDamage);
        smokeData = { x = oppositeSquare:getX(), y = oppositeSquare:getY(), z = oppositeSquare:getZ() };
        sendClientCommand("RC_Explosion", "SmokesUp", smokeData);
    end
end

local function RC_ApplyPlayerDamage(zPlayer, realPain)
    if not zPlayer then return end;

    --local playerHealth = zPlayer:getBodyDamage():getHealth();
    --print("Player Health: "..tostring(playerHealth)..", pain: "..tostring(realPain));
    zPlayer:getBodyDamage():getBodyPart(BodyPartType.Torso_Upper):AddDamage(realPain);
    if (IsRandomTrue(2)) then
        zPlayer:getBodyDamage():getBodyPart(BodyPartType.Head):AddDamage(realPain/4);
    end
    if (IsRandomTrue(2)) then
        zPlayer:getBodyDamage():getBodyPart(BodyPartType.Hand_R):AddDamage(realPain);
    end
    if (IsRandomTrue(2)) then
        zPlayer:getBodyDamage():getBodyPart(BodyPartType.Hand_L):AddDamage(realPain);
    end

    zPlayer:getBodyDamage():getBodyPart(BodyPartType.Head):setBleeding(IsRandomTrue(3));
    zPlayer:getBodyDamage():getBodyPart(BodyPartType.Torso_Upper):setBleeding(IsRandomTrue(3));
    zPlayer:getBodyDamage():getBodyPart(BodyPartType.UpperLeg_R):setBleeding(IsRandomTrue(3));
    zPlayer:getBodyDamage():getBodyPart(BodyPartType.UpperLeg_L):setBleeding(IsRandomTrue(3));
    zPlayer:getBodyDamage():getBodyPart(BodyPartType.ForeArm_L):setBleeding(IsRandomTrue(3));
    zPlayer:getBodyDamage():getBodyPart(BodyPartType.ForeArm_R):setBleeding(IsRandomTrue(3));

    zPlayer:getBodyDamage():Update();

    zPlayer:setBumpType("stagger");
    zPlayer:setVariable("BumpDone", false);
    zPlayer:setVariable("BumpFall", true);
    zPlayer:setVariable("BumpFallType", "pushedFront");
end

function RC_OnPainDelivery(module, command, executionData)
    if module ~= "RC_Explosion" then return end
    if command ~= "PainDelivery" then return end

    --print("Hello, this is Pain Delivery Service");
    local currentPlayer = getPlayer();

    local zNeo;
    if currentPlayer:getOnlineID() == executionData.executionerId then
        zNeo = currentPlayer;
        --print("Welcome Sir, You are now promoted to Neo");
    end

    if not zNeo then
        if WeAreInShowRange(executionData.x, executionData.y, currentPlayer:getX(), currentPlayer:getY()) == false then
            --print("Execution show is passing you by");
            return;
        end
    end

    local executionSquare = getCell():getOrCreateGridSquare(executionData.x, executionData.y, executionData.z);
    local zZombieList = executionSquare:getCell():getZombieList();

    for k, v in ipairs(executionData.zData) do
        if v then
            if v.targetType == "IsoZombie" then
                for i = 0, zZombieList:size()-1, 1 do
                    local zZombie = zZombieList:get(i);
                    local zombieId;
                    if SINGLEPLAYER then
                        zombieId = zZombie:getID();
                    else
                        zombieId = zZombie:getOnlineID();
                    end

                    if (zombieId == v.zId) then
                        local realPain = v.flatPain / 10;
                        if zNeo then
                            local zombieHealth = zZombie:getHealth();
                            --print("Delivery Receiver Health: "..tostring(zombieHealth)..", delivery amount: "..tostring(realPain));
                            zZombie:addRandomBloodDirtHolesEtc();
                            local executionTool = InventoryItemFactory.CreateItem("Base.RC_C4Virtual");
                            --print("Weapon: "..tostring(executionTool));

                            zZombie:Hit(executionTool, zNeo, realPain, false, 1, false);
                            zombieHealth = zZombie:getHealth();
                            --print("After Pain Delivery Receiver Health: "..tostring(zombieHealth));
                        end
                    end
                end
            end
        end
    end

    local onlinePlayers = zCommon.getOnlinePlayers();
    --print("Players found: "..tostring(onlinePlayers:size()));
    for i = 0, onlinePlayers:size()-1, 1 do
        --print("We are in online players loop");
        for k, v in ipairs(executionData.zData) do
            if v then
                --print("We are in zData loop, targetType: "..tostring(v.targetType));
                local realPain = v.flatPain / 3;
                if v.targetType == "IsoPlayer" then
                    if SINGLEPLAYER then
                        local zPlayer = v.ssObject;
                        --print("zPlayer: "..tostring(zPlayer));
                        RC_ApplyPlayerDamage(zPlayer, realPain);
                    else
                        local zPlayer = onlinePlayers:get(i);
                        local playerId = zPlayer:getOnlineID();
                        if (playerId == v.zId) then
                            --if zNeo then
                                RC_ApplyPlayerDamage(zPlayer, realPain);
                            --end
                        end
                    end
                end
            end
        end
    end

    local zSurvivorList =  executionSquare:getCell():getSurvivorList();
    for i = 0, zSurvivorList:size()-1, 1 do
        for k, v in ipairs(executionData.zData) do
            if v then
                --print("Survivor detected");
                local realPain = v.flatPain / 3;
                if v.targetType == "IsoGameCharacter" then
                    local zSurvivor = zSurvivorList:get(i);
                    if (zSurvivor:getOnlineID() == v.zId) then
                        if zNeo then
                            RC_ApplyPlayerDamage(zSurvivor, realPain);
                        end
                    end
                end
            end
        end
    end

end

function RC_OnSoundDelivery(module, command, explosionSoundData)
    if module ~= "RC_Explosion" then return end
    if command ~= "SoundDelivery" then return end
    --print("Sound Delivered");

    local epiCenterSquare = getCell():getGridSquare(explosionSoundData.epiX, explosionSoundData.epiY, explosionSoundData.epiZ);
    if epiCenterSquare then
        getSoundManager():PlayWorldSound(explosionSoundData.explosionSound, epiCenterSquare, 0, explosionSoundData.range, explosionSoundData.range, false);
    end
end

function RC_OnGarbageLocalEatery(module, command, garbageData)
    if module ~= "RC_Explosion" then return end
    if command ~= "GarbageEatery" then return end

    local detonatedSquare = getCell():getGridSquare(garbageData.x, garbageData.y, garbageData.z);

    if not detonatedSquare then
        --print("Not in detonated range");
        return;
    end

    local worldObjects = detonatedSquare:getObjects();
    local specialObjects = detonatedSquare:getSpecialObjects();
    local objectGraveList = {};

    if specialObjects:size() > 0 then
        for i = 0, specialObjects:size() - 1, 1 do
            local specialObj = specialObjects:get(i);
            --print("Final Spec Clean: "..tostring(specialObj));
            local props = specialObj:getProperties();
            local sprite = specialObj:getSprite();

            local baseBurnFound = false;
            if props then
                --local facing = props:Is("Facing") and props:Val("Facing") or nil;
                if not props:Is("FootstepMaterial") then
                    if sprite then
                        if (sprite:getName() == "floors_burnt_01_0") then
                            baseBurnFound = true;
                        end
                    end
                end
            end

            if baseBurnFound  ~= true then
                table.insert(objectGraveList, specialObj);
            end
        end
    end

    if worldObjects and not worldObjects:isEmpty() then
        local objs_size = worldObjects:size();
        if objs_size > 0 then
            for i = 0, objs_size - 1, 1 do
                local obj = worldObjects:get(i);
                --print("Final Clean: "..tostring(obj));
                local props = obj:getProperties();
                local sprite = obj:getSprite();

                local baseBurnFound = false;
                if props then
                    --local facing = props:Is("Facing") and props:Val("Facing") or nil;
                    if not props:Is("FootstepMaterial") then
                        if sprite then
                            if (sprite:getName() == "floors_burnt_01_0") then
                                baseBurnFound = true;
                            end
                        end
                    end
                end

                if baseBurnFound  ~= true then
                    table.insert(objectGraveList, obj);
                end
            end
        end
    end

    -- Removing All Previously skipped Objects From a Square
    for k, v in ipairs(objectGraveList) do
        if v then
            detonatedSquare:transmitRemoveItemFromSquare(v);
        end
    end

    detonatedSquare:removeAllWorldObjects();
end

function RC_OnLightRequiredCommand(module, command, args)
    if module ~= "RC_Explosion" then return end
    if command ~= "LightRequired" then return end

    local zNeo = getPlayer();

    if zNeo then
        zNeo:getInventory():AddItem("Battery");
        local lightBlank = ISLightSource:new("blankPoint_0", "blankPoint_1", zNeo);
        lightBlank.offsetX = 1;
        lightBlank.offsetY = 1;
        lightBlank:setEastSprite("blankPoint_2");
        lightBlank:setSouthSprite("blankPoint_3");
        lightBlank.fuel = "Base.Battery";
        lightBlank.baseItem = "Base.Battery";
        lightBlank.radius = args.rectLightRadius;
        lightBlank.player = zNeo.PlayerIndex;
        lightBlank:create(args.rectX, args.rectY, args.rectZ, lightBlank.north, lightBlank:getSprite());
    end
end

function RC_OnLocalObjectRemoval(module, command, args)
    if module ~= "RC_Explosion" then return end
    if command ~= "LocalObjectFastRemoval" then return end

    local targetSquare = getCell():getGridSquare(args.x, args.y, args.z);

    if not targetSquare then return end;
    local objectGraveList = {};

    local allWorldObjects = targetSquare:getWorldObjects();
    for i = 0, allWorldObjects:size() - 1, 1 do
        table.insert(objectGraveList, allWorldObjects:get(i));
    end

    for _,v in ipairs(objectGraveList) do
        targetSquare:removeWorldObject(v);
    end
end

function RC_OnNotAGoodNews(module, command, args)
    if module ~= "RC_Explosion" then return end
    if command ~= "NotAGoodNews" then return end

    local michael = getPlayer();
    if michael then
        local privateVehicle = michael:getVehicle();
        if privateVehicle then
            --print("Setting Smashed");
            if SINGLEPLAYER then
                local smashed = privateVehicle:setSmashed("Front", true);
                if smashed:getAngleZ() ~= 180 then
                    privateVehicle:setAngles(0, privateVehicle:getAngleY(), 180);
                end
            else
                local seat = privateVehicle:getSeat(michael);
                privateVehicle:exit(michael)
                privateVehicle:setCharacterPosition(michael, seat, "outside")

                privateVehicle:setAngles(0, privateVehicle:getAngleY(), 180);
                triggerEvent("OnExitVehicle", michael);
            end
        end
    end
end

function RC_OnLastNews(module, command, args)
    if module ~= "RC_Explosion" then return end
    if command ~= "LastNews" then return end

    local doomed = getPlayer();
    doomed:Kill(doomed);
end

function RC_OnItemFall(item)
    if item then
        --print("Item: " .. item:getDisplayName())
        if item:getDisplayName() == "Dynamite Charge" then
            local player = getPlayer();
            if player then
                local detonationSquare = player:getCurrentSquare();
                if detonationSquare then
                    local detonationData = { epiX = detonationSquare:getX(), epiY = detonationSquare:getY(), epiZ = detonationSquare:getZ(),
                                             rectObject = nil, fuseLength = nil, charges = 1 };

                    sendClientCommand("RC_Explosion", "DetonationRequest", detonationData);
                end
            end
        end
    end
end

Events.onItemFall.Add(RC_OnItemFall);

Events.OnServerCommand.Add(RC_OnDestructionInitiated);
Events.OnServerCommand.Add(RC_OnDemolitionInitiated);

Events.OnServerCommand.Add(RC_OnPainDelivery);
Events.OnServerCommand.Add(RC_OnSoundDelivery);
Events.OnServerCommand.Add(RC_OnGarbageLocalEatery);
Events.OnServerCommand.Add(RC_OnLightRequiredCommand);
Events.OnServerCommand.Add(RC_OnLocalObjectRemoval);
Events.OnServerCommand.Add(RC_OnNotAGoodNews);
Events.OnServerCommand.Add(RC_OnLastNews);



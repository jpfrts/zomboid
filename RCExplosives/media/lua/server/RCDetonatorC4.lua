---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by THeartnet.
--- DateTime: 10/11/2022 01:01
---

RCDetonatorC4 = {};

---@class RCDetonatorC4 : RCDetonator
RCDetonatorC4 = RCDetonator:derive("RCDetonatorC4");

function RCDetonatorBox:getDetonationType()
    return self.detonationType;
end

function RCDetonatorC4:new(x, y, z, rectObject)
    local rcDetonator = {};
    setmetatable(rcDetonator, self);
    self.__index = self;

    RCDetonatorC4.detonationType = rectObject:getName();

    rcDetonator.x = x;
    rcDetonator.y = y;
    rcDetonator.z = z;
    rcDetonator.oppositeSquare = nil;
    rcDetonator.rectObject = rectObject;
    local modData = rectObject:getModData();

    rcDetonator.type = modData["rect_type"];
    rcDetonator.guid = modData["rect_guid"];
    rcDetonator.remoteId = modData["rect_remoteControlId"];
    rcDetonator.facing = modData["rect_facing"];
    rcDetonator.charges = modData["rect_charges"]

    rcDetonator.targetFrame = modData["rect_targetFrame"];
    rcDetonator.targetWindow = modData["rect_targetWindow"];
    rcDetonator.targetDoor = modData["rect_targetDoor"];

    rcDetonator.targetProp = modData["rect_targetProp"];
    rcDetonator.targetNorth = modData["rect_targetNorth"];
    rcDetonator.targetBIndex = modData["rect_targetBIndex"];

    --print("guid: "..tostring(rcDetonator.guid)..", remoteId: "..tostring(rcDetonator.remoteId)..", frame: "..tostring(rcDetonator.targetFrame)..
    --        ", window: "..tostring(rcDetonator.targetWindow)..", door: "..tostring(rcDetonator.targetDoor)..
    --        ", prop: "..tostring(rcDetonator.targetProp)..", north: "..tostring(rcDetonator.targetNorth)..", bIndex: "..tostring(rcDetonator.targetBIndex)..
    --        ", rectType: "..tostring(rcDetonator.type));

    rcDetonator.explosionDamage = SandboxVars.RC.ExplosiveBaseDamage;-- RCExplosiveC4.ExplosionDamage;             -- need to passed from generic explosive
    rcDetonator.explosionSplashRadius = 3; --RCExplosiveC4.ExplosionSplashRadius; -- need to passed from generic explosive
    rcDetonator.explosionBlastSquares = 2; --RCExplosiveC4.ExplosionBlastSquares; -- need to passed from generic explosive
    rcDetonator.explosionSectionCount = 3; --RCExplosiveC4.ExplosionSectionCount; -- need to passed from generic explosive

    rcDetonator.activated = false;
    rcDetonator.executioner = nil;
    rcDetonator.empty = false;
    rcDetonator.fuseTime = 6.0;
    rcDetonator.currentFrame = -1;
    rcDetonator.frameCountFX = 48;
    rcDetonator.lastVisualObject = nil;
    rcDetonator.lightEstablished = false;

    return rcDetonator;
end

function RCDetonatorC4:activate(player)
    self.executioner = player;
    self.activated = true;
end

function RCDetonatorC4:applyExplosionInitialEffects(detonationSquare)

    local destructionData = { x=self.x, y=self.y, z=self.z, facing=self.facing, explosionDamage=self.explosionDamage,
                              explosionSplashRadius = self.explosionSplashRadius,
                              explosionSectionCount = self.explosionSectionCount};
    if not isClient() and not isServer() and not isCoopHost() then
        RC_OnDestructionInitiated("RC_Explosion", "DestructionInitiated", destructionData);
    else
        sendServerCommand(self.executioner, "RC_Explosion", "DestructionInitiated", destructionData);
    end

    if self.rectObject then
        detonationSquare:transmitRemoveItemFromSquare(self.rectObject);
    end
end

function RCDetonatorC4:applyExplosionMidEffects(detonationSquare)
    if detonationSquare then
        --detonationSquare:Burn();
        --[[local buildItem = ISSimpleFurniture:new("FLOOR", "floors_burnt_01", "floors_burnt_01");
        buildItem.character = self.executioner;
        buildItem:create(detonationSquare:getX(), detonationSquare:getY(), detonationSquare:getZ(),
                buildItem.north, buildItem.spriteName);]]
    end

    if self.oppositeSquare then
        self.oppositeSquare:Burn();
    end
end

function RCDetonatorC4:applyExplosionPostEffects(detonationSquare)
    if detonationSquare then
        local garbageData = { x=self.x, y=self.y, z=self.z };
        if not isServer() and not isClient() and not isCoopHost() then
            RC_OnGarbageLocalEatery("RC_Explosion", "GarbageEatery", garbageData);
        else
            sendServerCommand("RC_Explosion", "GarbageEatery", garbageData);
        end
    end
end

function RCDetonatorC4:explode()

    local innerSquareX;
    local innerSquareY;
    if self.facing == "E" then
        --self.oppositeSquare = getCell():getGridSquare(x - 1, y, z);
        innerSquareX = 0.5;
        innerSquareY = 1.5;
        -- confirmed
        self.oppositeSquare = getCell():getGridSquare(self.x-1, self.y, self.z);
    end

    if self.facing == "W" then
        --self.oppositeSquare = getCell():getGridSquare(x + 1, y, z);
        innerSquareX = 1.5;
        innerSquareY = 1.5;
        -- confirmed
        self.oppositeSquare = getCell():getGridSquare(self.x+1, self.y, self.z);
    end

    if self.facing == "N" then
        --self.oppositeSquare = getCell():getGridSquare(x, y + 1, z);
        innerSquareX = 0.5;
        innerSquareY = 1.5;
        -- confirmed
        self.oppositeSquare = getCell():getGridSquare(self.x, self.y+1, self.z);
    end

    if self.facing == "S" then
        --self.oppositeSquare = getCell():getGridSquare(x, y - 1, z);
        innerSquareX = 0.5;
        innerSquareY = 0.5;
        -- confirmed
        self.oppositeSquare = getCell():getGridSquare(self.x, self.y-1, self.z);
    end

    local detonationSquare = getCell():getGridSquare(self.x, self.y, self.z);
    if self.lastVisualObject then
        if self.lastVisualObject:getWorldItem() then
            detonationSquare:transmitRemoveItemFromSquare(self.lastVisualObject:getWorldItem());
            --detonationSquare:transmitRemoveItemFromSquareOnServer(self.lastVisualObject:getWorldItem());

            detonationSquare:removeWorldObject(self.lastVisualObject:getWorldItem());
        end
    end
    detonationSquare:removeAllWorldObjects();
    if self.rectObject then
        detonationSquare:transmitRemoveItemFromSquare(self.rectObject);
    end

    -- precise area explosion
    if self.currentFrame < self.frameCountFX then
        self.currentFrame = self.currentFrame + 1;
        if isServer() and self.currentFrame ~= 0 then
            -- Multiplayer frame skip
            self.currentFrame = self.currentFrame + 3;
        end

        local worldInventoryItem;

        -- Light works
        local zNeo = nil;
        local lightRequiredData = { rectX = self.x, rectY = self.y, rectZ = self.z, rectLightRadius = 10 };

        if self.lightEstablished ~= true then
            self.lightEstablished = true;
            if not isServer() and not isClient() and not isCoopHost() then
                RC_OnLightRequiredCommand("RC_Explosion", "LightRequired", lightRequiredData);
            else
                zNeo = RDC_CheckZoneHasPlayer(detonationSquare);
                sendServerCommand(zNeo, "RC_Explosion", "LightRequired", lightRequiredData);
            end
        end
        -- Light works end

        if not isClient() and not isServer() and not isCoopHost() then
            local itemBaseName = "Base.RCFX_ExplosionC4";
            local explosionVisuals = ScriptManager.instance:getItem(itemBaseName);
            local visualsIconName = "c4explosionFX"..tostring(self.currentFrame);
            explosionVisuals:DoParam("Icon = "..tostring(visualsIconName));
            worldInventoryItem = detonationSquare:AddWorldInventoryItem(itemBaseName, innerSquareX, innerSquareY, 0);
        else
            local itemRCVisualsName = "RCVisuals.RCFX_ExplC4_"..tostring(self.currentFrame);
            worldInventoryItem = detonationSquare:AddWorldInventoryItem(itemRCVisualsName, innerSquareX, innerSquareY, 0);
        end
        self.lastVisualObject = worldInventoryItem;

        if self.currentFrame == 0 then
            local explosionSound = "RCExplosionSoundC4";
            local onlinePlayers = zCommon.getOnlinePlayers();

            for i=0, onlinePlayers:size()-1, 1 do
                local currentPlayer = onlinePlayers:get(i);

                if zCommon.isInRange(self.x, self.y, currentPlayer:getX(), currentPlayer:getY(), 85) then
                    local explosionSoundData = { epiX = self.x, epiY = self.y, epiZ = self.z, explosionSound = explosionSound, range = 70};
                    local module = "RC_Explosion";
                    local command = "SoundDelivery";

                    if not isClient() and not isServer() and not isCoopHost() then
                        RC_OnSoundDelivery(module, command, explosionSoundData)
                    else
                        sendServerCommand(currentPlayer, module, command, explosionSoundData);
                    end
                end
            end

            addSound(getPlayer(), self.x, self.y, self.z, 150, 1);
        end
        if self.currentFrame == 4 then
            -- do terrain area damage
            --print("Ouch!");
            self:applyExplosionInitialEffects(detonationSquare);
        end

        if self.currentFrame == 16 then
            self:applyExplosionMidEffects(detonationSquare);
        end

        if self.currentFrame == (self.frameCountFX - 4) then
            self:applyExplosionPostEffects(detonationSquare);
        end

        return false;
    else
        if self.lastVisualObject then
            if self.lastVisualObject:getWorldItem() then
                detonationSquare:transmitRemoveItemFromSquare(self.lastVisualObject:getWorldItem());
                --detonationSquare:transmitRemoveItemFromSquareOnServer(self.lastVisualObject:getWorldItem());

                detonationSquare:removeWorldObject(self.lastVisualObject:getWorldItem());
            end
        end

        --print("Removing all for: "..tostring(self.guid));
        detonationSquare:removeAllWorldObjects();

        return true;
    end
end

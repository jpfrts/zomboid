---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by THeartnet.
--- DateTime: 10/11/2022 01:01
---

RCDetonatorBox = {};

---@class RCDetonatorBox : RCDetonator
RCDetonatorBox = RCDetonator:derive("RCDetonatorBox");

RCDetonatorBox.blastAnimSizes = {
    small = '512',
    medium = '768',
    large = '1024',
    insane = '2048'
};

RCDetonatorBox.explosionSounds = {
    small = 'RCExplosionSoundBoxSmall',
    medium = 'RCExplosionSoundBoxMedium',
    large = 'RCExplosionSoundBoxLarge',
    insane = 'RCExplosionSoundBoxInsane'
};

RCDetonatorBox.explosionCarSounds = {["0"]='RCExplosionSoundCarSmall', ["1"]='RCExplosionSoundCarMedium', ["2"]='RCExplosionSoundCarLarge',
                                     ["3"]='RCExplosionSoundCarSpecial', ["4"]='RCExplosionSoundMetalSmall', ["5"]='RCExplosionSoundMetalMedium',
                                     ["6"]='RCExplosionSoundMetalLarge' };

function RCDetonatorBox:getDetonationType()
    return self.detonationType;
end

---@public constructor could be exposed for any sort of explosions just possible
---@param x String - x coordinate of explosion
---@param y String - y coordinate of explosion
---@param z String - z coordinate of explosion
---@param rectObject any related to RCExplosives mod which contains nested modData
---@param fuseLength int - delay until explosion
---@param charges int - determines explosion range and its damage (0 - 20) scaling from SANDBOX damage value, 0 means no explosion
---@return void
function RCDetonatorBox:new(x, y, z, rectObject, fuseLength, charges)
    local rcDetonator = {};
    setmetatable(rcDetonator, self);
    self.__index = self;

    rcDetonator.x = x;
    rcDetonator.y = y;
    rcDetonator.z = z;

    rcDetonator.rectObject = rectObject;

    if rectObject then
        local modData = rectObject:getModData();
        RCDetonatorBox.detonationType = modData["rect_type"];

        rcDetonator.type = modData["rect_type"];
        rcDetonator.guid = modData["rect_guid"];
        rcDetonator.remoteId = modData["rect_remoteControlId"];
        rcDetonator.charges = modData["rect_charges"];

        rcDetonator.fuseTime = 6.0;
    else
        -- Default Extra Explosion
        rcDetonator.generic = true;
        RCDetonatorBox.detonationType = "GenericExplosion"

        rcDetonator.type = "Generic";
        rcDetonator.guid = nil;
        rcDetonator.remoteId = nil;

        if charges then
            rcDetonator.charges = tostring(charges);
        else
            -- default charges value for all simple explosions
            rcDetonator.charges = "7";
        end

        if fuseLength then
            rcDetonator.fuseTime = fuseLength;
        else
            if not isClient() and not isServer() and not isCoopHost() then
                rcDetonator.fuseTime = 0.1;
            else
                local recentlyAffectedSquares = RCDetonator.getRecentCount();

                if recentlyAffectedSquares == 0 then
                    rcDetonator.fuseTime = 0.1;
                else
                    rcDetonator.fuseTime = recentlyAffectedSquares / 1500;

                    if rcDetonator.fuseTime <= 0.1 then
                        rcDetonator.fuseTime = 0.1;
                    end
                end
            end
        end
    end

    --print("guid: "..tostring(rcDetonator.guid)..", remoteId: "..tostring(rcDetonator.remoteId)..", frame: "..
    --        ", rectType: "..tostring(rcDetonator.type));

    rcDetonator.lightEstablished = false;
    rcDetonator.activated = false;
    rcDetonator.initiated = false;
    rcDetonator.annihilated = false;

    rcDetonator.executioner = nil;
    rcDetonator.empty = false;
    rcDetonator.currentFrame = -1;
    rcDetonator.frameCountFX = 48;
    rcDetonator.lastVisualObject = nil;
    rcDetonator.minRadius = 4;
    rcDetonator.minEnergy = 0.2;
    rcDetonator.step = 2;
    rcDetonator.soundRangeMultiplier = 15;
    rcDetonator.blastRadius = 0;
    rcDetonator.unleashedEnergy = 0.0;

    rcDetonator.toBeDemolished = nil;
    rcDetonator.globalMaxCordIndex = -1;

    return rcDetonator;
end

function RCDetonatorBox:activate(player)
    self.executioner = player;
    self.activated = true;
end

function RCDetonatorBox.executeVehicleDetonation(detonationSquare, resultUniqueCords, executioner)

    local vehicleHash = {};
    local zNeo;

    if executioner then
        zNeo = executioner;
    else
        zNeo = RDC_CheckZoneHasPlayer(detonationSquare);
    end

    for _, v in  ipairs(resultUniqueCords) do
        if v.blackHole == true then
            local vehicleSquare = getCell():getGridSquare(v.exX, v.exY, v.exZ);
            if vehicleSquare then
                local vehicle = vehicleSquare:getVehicleContainer();
                if vehicle then
                    local vehicleId = vehicle:getId();
                    if (not vehicleHash[vehicleId]) then
                        if (not RCDetonator.vehicleHash[vehicleId]) then
                            --print("Explosion for id: "..tostring(vehicleId));
                            vehicleHash[vehicleId] = true;
                            RCDetonator.vehicleHash[vehicleId] = true;

                            local vehicleSquare_v2 = vehicle:getSquare();
                            local epiX = v.exX;
                            local epiY = v.exY;
                            local epiZ = v.exZ;

                            if vehicleSquare then
                                epiX = vehicleSquare_v2:getX();
                                epiY = vehicleSquare_v2:getY();
                                epiZ = vehicleSquare_v2:getZ();
                                --print("Initial Square X: "..tostring(v.exX)..", Y: "..tostring(v.exY)..tostring(v.exZ));
                                --print("Vehicle Square X: "..tostring(epiX)..", Y: "..tostring(epiY)..tostring(epiZ));
                            end

                            local trueArt = true;
                            if SandboxVars.RC.MyArtIsAnExplosion == false then
                                --print("My Art is False");
                                local zeroIndexedPart = vehicle:getPartByIndex(0);
                                --print("Zero Part: "..tostring(zeroIndexedPart));
                                if not zeroIndexedPart then
                                    trueArt = false;
                                end
                            end

                            if trueArt == true then
                                local luckyDriver = vehicle:getDriver();
                                local fuseLength = nil;

                                if not RCDetonator.crashedHash[vehicleId] then
                                    if luckyDriver then
                                        local happySquare = getCell():getGridSquare(luckyDriver:getX(),luckyDriver:getY(), luckyDriver:getZ());
                                        if happySquare then
                                            epiX = happySquare:getX();
                                            epiY = happySquare:getY();
                                            epiZ = happySquare:getZ();
                                        end
                                        -- Lets inform a driver that he is going to be flipped and exploded as a result
                                        local message = { notAGoodNews = true };
                                        fuseLength = ZombRand(25, 46);

                                        RCDetonator.crashedHash[vehicleId] = true;
                                        if SINGLEPLAYER then
                                            RC_OnNotAGoodNews("RC_Explosion", "NotAGoodNews", message);
                                        else
                                            sendServerCommand(luckyDriver, "RC_Explosion", "NotAGoodNews", message);
                                        end

                                        if SINGLEPLAYER then
                                            local seat = vehicle:getSeat(luckyDriver);
                                            vehicle:exit(luckyDriver)
                                            vehicle:setCharacterPosition(luckyDriver, seat, "outside")

                                            triggerEvent("OnExitVehicle", luckyDriver);
                                        end
                                    end

                                    local detonator = RCDetonatorBox:new(epiX, epiY, epiZ, nil, fuseLength);
                                    detonator:activate(zNeo);
                                    table.insert(RDC_Z_server.detonationList, detonator);
                                else
                                    local suicideSquadCount = vehicle:getMaxPassengers();
                                    for seat=0, suicideSquadCount - 1, 1 do
                                        if vehicle:isSeatOccupied(seat) then
                                            local suicido = vehicle:getCharacter(seat);
                                            if suicido then
                                                --print("Suicide found at seat: "..tostring(seat));
                                                if SINGLEPLAYER then
                                                    suicido:Kill(zNeo);
                                                else
                                                    local message = { lastNews = true };
                                                    sendServerCommand(suicido, "RC_Explosion", "LastNews", message);
                                                end
                                            end
                                        end
                                    end

                                    local vehicleCords = { x = epiX, y = epiY, z = epiZ, lastCall = true };
                                    RCDetonator.crashedHash[vehicleId] = nil;
                                    On_WreckIt("RC_Explosion", "WreckIt", nil, vehicleCords);
                                end
                            end
                        end
                    end
                end
            end
        end
    end
end

function RCDetonatorBox:applyExplosionInitialEffects(detonationSquare)
    self.toBeDemolished = RCDetonatorBox.leaveYourCoordinatesHere(detonationSquare, self.blastRadius);

    if self.toBeDemolished then
        if self.toBeDemolished.uniqueCordsData then
            RCDetonatorBox.executeVehicleDetonation(detonationSquare, self.toBeDemolished.uniqueCordsData, self.executioner);

            local demolitionData = { tabledCords = self.toBeDemolished.uniqueCordsData,
                                     blastIntensity = self.charges, unleashedEnergy = self.unleashedEnergy,
                                     epiX = self.x, epiY = self.y, epiZ = self.z,
                                     blastRadius = self.blastRadius, blastFloorZData = self.toBeDemolished.floorZData };

            if not isClient() and not isServer() and not isCoopHost() then
                --print("Sending DemolitionData");
                RC_OnDemolitionInitiated("RC_Explosion", "DemolitionInitiated", demolitionData);
            else
                sendServerCommand(self.executioner, "RC_Explosion", "DemolitionInitiated", demolitionData);
            end
        end
    end

    if self.rectObject then
        detonationSquare:transmitRemoveItemFromSquare(self.rectObject);
    end

    SmokesUp();
end

function RCDetonatorBox.getIdFromCords(x, y, z)
    return "x"..tostring(x).."y"..tostring(y).."z"..tostring(z);
end

function RCDetonatorBox.leaveYourCoordinatesHere(detonationSquare, blastRadius)
    -- Explosion Charge Dependency
    if not detonationSquare then return nil end;

    local epiX = detonationSquare:getX();
    local epiY = detonationSquare:getY();
    local epiZ = detonationSquare:getZ();

    local maxFloorLevel = 7;
    local blackHolePerBurnProportion = 3;

    local highestZPotential = 0;
    local currentBlastPotential = blastRadius;
    local blastReductionImmunity = true;

    -- prevents from explosion of same squares multiple time in a short period of time
    RCDetonator.recentTimer = RCDetonator.recentInterval;

    local floorZData = {};
    local actualFloorZData = {};

    for i=0, maxFloorLevel, 1 do
        if currentBlastPotential > 4 then
            local zData = { zIndex = i, zBlastRadius = currentBlastPotential };
            table.insert(floorZData, zData);
            if blastReductionImmunity == true then
                blastReductionImmunity = false;
            else
                currentBlastPotential = currentBlastPotential - 4;
            end

            highestZPotential = highestZPotential + 1;
        else
            if currentBlastPotential == 4 then
                local zData = { zIndex = i, zBlastRadius = currentBlastPotential };
                table.insert(floorZData, zData);
                currentBlastPotential = 2;
                highestZPotential = highestZPotential + 1;
            else
                if currentBlastPotential == 2 then
                    local zData = { zIndex = i, zBlastRadius = currentBlastPotential };
                    table.insert(floorZData, zData);
                    currentBlastPotential = 0;
                    highestZPotential = highestZPotential + 1;
                else
                    -- blast potential is zero
                    break;
                end
            end
        end
    end

    local targetCords = {};
    local detonationSquareRCId = RCDetonatorBox.getIdFromCords(epiX, epiY, epiZ);
    --[[local mainCordsData = { exX = epiX, exY = epiY, exZ = epiZ,
                        radius = epiZ, blackHole = true };
    table.insert(targetCords, mainCordsData);]]

    local lowestBlastZ = epiZ - highestZPotential;
    local highestBlastZ = epiZ + highestZPotential;

    if lowestBlastZ < 0 then
        lowestBlastZ = 0;
    end

    if highestBlastZ > maxFloorLevel then
        highestBlastZ = maxFloorLevel;
    end

    for iZ=lowestBlastZ, highestBlastZ, 1 do

        local currentExplosiveRadius = 2;
        local currentIndex = zCommon._abs(iZ - epiZ);

        for _, v in ipairs(floorZData) do
            if v then
                if v.zIndex == currentIndex then
                    currentExplosiveRadius = v.zBlastRadius;
                    break;
                end
            end
        end

        local actualZData = { zLevel = iZ, blastRadius = currentExplosiveRadius };
        table.insert(actualFloorZData, actualZData );
        --local holeRadius =  currentExplosiveRadius - toInt(currentExplosiveRadius / blackHolePerBurnProportion)

        local fullPieces = toInt(currentExplosiveRadius / 4);
        local inc = 1;
        --[[if currentExplosiveRadius % 4 ~= 0 thend
            inc = 1;
        end]]

        local onTopRow = fullPieces + inc;
        local pairs = 0;
        local n = currentExplosiveRadius; --

        --print("fullPieces: "..tostring(fullPieces)..", inc: "..tostring(inc)..", onTopRow: "..tostring(onTopRow));

        local x;
        local y;

        local highestXOffset_upperLeft = 0;
        local highestYOffset_upperLeft = 0;
        local lightBurnArea = 0;
        local is2x2 = false;

        for b = 0, currentExplosiveRadius, 2 do
            is2x2 = (not is2x2);
            if b > 2 and is2x2 == false then
                lightBurnArea = lightBurnArea + 1;
            end
        end

        --print("Explosion Radius: "..tostring(currentExplosiveRadius)..", LightBurnArea: "..tostring(lightBurnArea));

        for xX = -1, 1, 2 do
            for yY = 1, -1, -2 do
                local breakingLast = false;
                local yShift = 0;
                local xShift = 0;

                if yY < 0 then
                    yShift = -1;
                end

                if xX > 0 then
                    xShift = 1;
                end

                if (is2x2 == true) then
                    --print("We are is2x2");
                else
                    --print("We are not is2x2");
                end

                if is2x2 == true then
                    -- 2x2
                    pairs = onTopRow - 1;
                else
                    pairs = onTopRow;
                end

                highestYOffset_upperLeft = ((n - 1) * yY) + yShift;
                highestXOffset_upperLeft = ((n - 1) * xX) + xShift;
                local pairIndex = 0;
                for z = 0, n + xShift, 1 do -- actions count - z
                    if z == 0 then
                        -- first action
                        x = highestXOffset_upperLeft;
                        y = ((onTopRow - 1) * yY) + yShift;
                        --print("first action x: "..tostring(x)..", y: "..tostring(y));
                        pairs = pairs - 1;
                        if pairs == 0 then
                            if is2x2 == false then
                                pairs = -1;
                            end
                        end
                    end

                    --print("n: "..tostring(n + xShift)..", z: "..tostring(z));
                    if (z ~= 0) and ((z + 1) < (n + xShift)) then
                        -- middle actions
                        x = x + ((-1) * xX);
                        --print("Middle x: "..tostring(x));
                        if pairs > 0 then
                            -- positive pairs
                            y = y + (2 * yY);
                            pairs = pairs - 1;
                            --print("middle action, positive pairs x: "..tostring(x)..", y: "..tostring(y));
                            if pairs == 0 then
                                if is2x2 == false then
                                    pairs = -1;
                                end
                            end
                        else
                            if pairs == 0 then
                                -- pairs == 0
                                y = y + (1 * yY);
                                pairs = pairs - 1;
                                --print("middle action, pairs==0 x: "..tostring(x)..", y: "..tostring(y));
                            else
                                -- negative pairs
                                if zCommon._abs(y) < zCommon._abs(highestYOffset_upperLeft) then
                                    if pairIndex == 0 then
                                        y = y + (1 * yY);
                                        pairIndex = 1;
                                    else
                                        y = y;
                                        pairIndex = 0;
                                        pairs = pairs - 1;
                                    end
                                else
                                    y = highestYOffset_upperLeft;
                                end
                                --print("middle action, negative pairs x: "..tostring(x)..", y: "..tostring(y));
                            end
                        end
                    end

                    if (z + 1) == (n + xShift) then
                        -- last action
                        x = 0 + xShift;
                        y = highestYOffset_upperLeft;
                        breakingLast = true;
                        --print("last action x: "..tostring(x)..", y: "..tostring(y));
                    end

                    for k = y, (0 + yShift), ((-1)*yY) do
                        local isHole = true;

                        --[[if (k == y or(zCommon._abs(k) == (zCommon._abs(y) - 1))) then
                            isHole = false;
                        end]]

                        if (zCommon._abs(k) >= (zCommon._abs(y) -  lightBurnArea)) then
                            isHole = false;
                            --print("LightBurn byY x: "..tostring(x)..", y: "..tostring(k));
                        end

                        --[[if z <= lightBurnArea then
                            isHole = false;
                            print("LightBurn byX x: "..tostring(x)..", y: "..tostring(k));
                        end]]
                        local finalEpiX = (epiX + x);
                        local finalEpiY = (epiY + k);
                        local finalEpiZ = iZ;

                        -- SafeHouse damage prevention
                        local skippingAsSafe = false;
                        if SandboxVars.RC.SafeHouseSafeness ~= 1 then
                            local actualSquare = getCell():getGridSquare(epiX + x, epiY + k, iZ);
                            if actualSquare then
                                local safeZone = SafeHouse.isSafeHouse(actualSquare, nil, true);
                                if safeZone then
                                    skippingAsSafe = true;
                                end
                            end
                        end
                        --

                        if skippingAsSafe == false then
                            local rcId = RCDetonatorBox.getIdFromCords(finalEpiX, finalEpiY, finalEpiZ);
                            local cordsData = { exX = (epiX + x), exY = (epiY + k), exZ = iZ,
                                                radius = currentExplosiveRadius, blackHole = isHole };

                            if (not RCDetonator.recentlyExplodedHash[rcId] or detonationSquareRCId == rcId) then
                                if isHole == true then
                                    RCDetonator.recentlyExplodedHash[rcId] = true;
                                end

                                table.insert(targetCords, cordsData);
                            end
                        else
                            --print("Skipping as SafeZone, X:"..tostring(epiX + x)..", Y: "..tostring(epiY + k)..", Z: "..tostring(iZ));
                        end
                    end

                    if breakingLast == true then
                        break;
                    end
                end
            end
        end
    end

    local hash = {};
    local resultUniqueCords = {};

    for _,v in ipairs(targetCords) do
        if v then
            local zId = RCDetonatorBox.getIdFromCords(v.exX, v.exY, v.exZ);
            if (not hash[zId]) then
                local smoke = { x = v.exX, y = v.exY, z = v.exZ };
                table.insert(RCDetonator.recentSmokes, smoke);
                table.insert(resultUniqueCords, v);
                hash[zId] = true;
            else
                --print("Duplicate found");
            end
        end
    end

    local coordinateData = { uniqueCordsData = resultUniqueCords,  floorZData = actualFloorZData };

    return coordinateData;
end

function RCDetonatorBox:applyExplosionMidEffects(detonationSquare)
    if detonationSquare then
        --detonationSquare:Burn();
        --[[local buildItem = ISSimpleFurniture:new("FLOOR", "floors_burnt_01", "floors_burnt_01");
        buildItem.character = self.executioner;
        buildItem:create(detonationSquare:getX(), detonationSquare:getY(), detonationSquare:getZ(),
                buildItem.north, buildItem.spriteName);]]
    end
end

function RCDetonatorBox:applyExplosionPostEffects(detonationSquare)

end

function RCDetonatorBox:getBlastResolution(blastRadius)
    local blastResPrefix = self.blastAnimSizes.small;

    if blastRadius == self.minRadius then
        blastResPrefix = self.blastAnimSizes.small;
    end

    if blastRadius == (self.minRadius + self.step) then
        blastResPrefix = self.blastAnimSizes.medium;
    end

    if blastRadius == (self.minRadius + (self.step * 2)) then
        blastResPrefix = self.blastAnimSizes.large;
    end

    if blastRadius >= (self.minRadius + (self.step * 3)) then
        blastResPrefix = self.blastAnimSizes.insane;
    end

    return blastResPrefix;
end

function RCDetonatorBox:getBlastSound(blastRadius)
    local blastSound = self.explosionSounds.small;

    if blastRadius == self.minRadius then
        blastSound = self.explosionSounds.small;
    end

    if blastRadius == (self.minRadius + self.step) then
        blastSound = self.explosionSounds.medium;
    end

    if blastRadius == (self.minRadius + (self.step * 2)) then
        blastSound = self.explosionSounds.large;
    end

    if blastRadius >= (self.minRadius + (self.step * 3)) then
        blastSound = self.explosionSounds.insane;
    end

    return blastSound;
end

function RCDetonatorBox:explode()
    local detonationSquare = getCell():getGridSquare(self.x, self.y, self.z);
    if self.lastVisualObject then
        if self.lastVisualObject:getWorldItem() then
            detonationSquare:transmitRemoveItemFromSquare(self.lastVisualObject:getWorldItem());
            detonationSquare:removeWorldObject(self.lastVisualObject:getWorldItem());
        end
    end

    local blastIntensity =  toInt((self.charges - 1) / 4);
    self.unleashedEnergy = self.minEnergy + (((self.charges -1) % 4) / 4);
    self.blastRadius = self.minRadius + (self.step * blastIntensity);
    local blastResPrefix = self:getBlastResolution(self.blastRadius);

    if self.currentFrame < self.frameCountFX then
        self.currentFrame = self.currentFrame + 1;
        if isServer() and self.currentFrame ~= 0 then
            -- Multiplayer frame skip
            --self.currentFrame = self.currentFrame + 3;
            if self.currentFrame < 8 then
                self.currentFrame = self.currentFrame + 2;
            else
                if blastResPrefix == self.blastAnimSizes.insane or
                        blastResPrefix == self.blastAnimSizes.large then
                    -- no frame skim, slow huge explosion
                else
                    self.currentFrame = self.currentFrame + 1;
                end
            end
        end

        if not self.charges or tonumber(self.charges) <= 0 then
            -- blank explosion
            return;
        end

        detonationSquare:removeAllWorldObjects();
        if self.rectObject then
            detonationSquare:transmitRemoveItemFromSquare(self.rectObject);
        end

        if not isServer() and not isClient() and not isCoopHost() then

        else
            local squareData = { x = self.x, y = self.y, z = self.z };
            sendServerCommand("RC_Explosion", "LocalObjectFastRemoval", squareData);
        end

        -- Light works
        local zNeo = nil;
        local lightRequiredData = { rectX = self.x, rectY = self.y, rectZ = self.z, rectLightRadius = 20 * self.charges };

        if self.lightEstablished ~= true then
            self.lightEstablished = true;
            if not isServer() and not isClient() and not isCoopHost() then
                RC_OnLightRequiredCommand("RC_Explosion", "LightRequired", lightRequiredData);
            else
                zNeo = RDC_CheckZoneHasPlayer(detonationSquare);
                sendServerCommand(zNeo, "RC_Explosion", "LightRequired", lightRequiredData);
            end
        end
        -- Light works end

        local worldInventoryItem;
        if not isClient() and not isServer() and not isCoopHost() then
            local itemBaseName = "Base.RCFX_ExplosionC4";
            local explosionVisuals = ScriptManager.instance:getItem(itemBaseName);
            --local blastResPrefix = self:getBlastResolution(self.blastRadius);

            local visualsIconName = tostring(blastResPrefix).."_rc_explosion_FX_"..tostring(self.currentFrame);

            explosionVisuals:DoParam("Icon = "..tostring(visualsIconName));
            worldInventoryItem = detonationSquare:AddWorldInventoryItem(itemBaseName, 0.5, 0.5, 0);
        else

            local itemRCVisualsName = "RCVisuals."..blastResPrefix.."_rc_explosion_FX_"..tostring(self.currentFrame);

            worldInventoryItem = detonationSquare:AddWorldInventoryItem(itemRCVisualsName, 0.5, 0.5, 0);
        end
        self.lastVisualObject = worldInventoryItem;

        if self.currentFrame == 0 then
            local explosionSound;
            if self.generic then
                local randomSelector = round(ZombRand(0, 7));
                explosionSound = RCDetonatorBox.explosionCarSounds[tostring(randomSelector)];
            else
                explosionSound = self:getBlastSound(self.blastRadius);
            end
            local onlinePlayers = zCommon.getOnlinePlayers();
            local soundRange = self.blastRadius * self.soundRangeMultiplier;

            for i=0, onlinePlayers:size()-1, 1 do
                local currentPlayer = onlinePlayers:get(i);

                if zCommon.isInRange(self.x, self.y, currentPlayer:getX(), currentPlayer:getY(), 180) then

                    local explosionSoundData = { epiX = self.x, epiY = self.y, epiZ = self.z, explosionSound = explosionSound, range = soundRange };
                    local module = "RC_Explosion";
                    local command = "SoundDelivery";

                    if not isClient() and not isServer() and not isCoopHost() then
                        RC_OnSoundDelivery(module, command, explosionSoundData)
                    else
                        sendServerCommand(currentPlayer, module, command, explosionSoundData);
                    end
                end
            end

            addSound(zNeo, self.x, self.y, self.z, soundRange, 1);
        end

        if self.currentFrame >= 4 and self.initiated == false then
            self.initiated = true;
            self:applyExplosionInitialEffects(detonationSquare);
        end

        return false;
    else
        if self.lastVisualObject then
            if self.lastVisualObject:getWorldItem() then
                detonationSquare:transmitRemoveItemFromSquare(self.lastVisualObject:getWorldItem());
                --detonationSquare:transmitRemoveItemFromSquareOnServer(self.lastVisualObject:getWorldItem());

                detonationSquare:removeWorldObject(self.lastVisualObject:getWorldItem());
            end
        end

        if self.charges and tonumber(self.charges) > 0 then
            local garbageData = { x=self.x, y=self.y, z=self.z };
            detonationSquare:removeAllWorldObjects();
            --print("Removing all for: "..tostring(self.guid));

            sendServerCommand("RC_Explosion", "GarbageEatery", garbageData);
        end

        return true;
    end
end

local function RC_InitSandVariables()
    --if not SandboxVars.RC.MyArtIsAnExplosion then SandboxVars.RC.MyArtIsAnExplosion = true end
    --if not SandboxVars.RC.ExplosiveBaseDamage then SandboxVars.RC.ExplosiveBaseDamage = 350 end
    --if not SandboxVars.RC.SafeHouseSafeness then SandboxVars.RC.SafeHouseSafeness = 1 end
end

function SmokesUp()
    for _, v in ipairs(RCDetonator.recentSmokes) do
        local smokingSquare = getCell():getGridSquare(v.x, v.y, v.z);
        if smokingSquare then
            IsoFireManager.RemoveAllOn(smokingSquare);
            IsoFireManager.StartSmoke(getCell(), smokingSquare, true, 200, 500);
        end
    end
end

function On_SmokesUp(module, command, player, args)
    if module ~= "RC_Explosion" then return end
    if command ~= "SmokesUp" then return end

    local smokingSquare = getCell():getGridSquare(args.x, args.y, args.z);
    IsoFireManager.StartSmoke(getCell(), smokingSquare, true, 200, 500);
end

function On_BurnItDown(module, command, player, args)
    if module ~= "RC_Explosion" then return end
    if command ~= "BurnItDown" then return end

    local crispySquare = getCell():getGridSquare(args.x, args.y, args.z);
    if crispySquare then
        crispySquare:Burn();
    end
end

function On_WreckIt(module, command, player, args)
    if module ~= "RC_Explosion" then return end
    if command ~= "WreckIt" then return end

    local wreckySquare = getCell():getGridSquare(args.x, args.y, args.z);
    if wreckySquare then
        local vehicle = wreckySquare:getVehicleContainer();
        if vehicle then
            if not RCDetonator.crashedHash[vehicle:getId()] then
                local driver = vehicle:getDriver();
                if driver then
                    if args.lastCall then
                        vehicle:permanentlyRemove();
                        vehicle:removeFromWorld();
                    else
                        print("Driver: "..tostring(driver)..", angleZ: "..tostring(vehicle:getAngleZ()));
                    end
                else
                    vehicle:permanentlyRemove();
                    vehicle:removeFromWorld();
                end
            end
        end
    end
end

function On_TakeOff(module, command, player, args)
    if module ~= "RC_Explosion" then return end
    if command ~= "TakeOff" then return end

    --print("Flight Pacific 7500 - TakeOff, I'm your capitan with id: "..tostring(args.kiraId));
    local flightDataObject = { flightPacific7500 = args.flightData, kiraId = args.kiraId,
                               epiX = args.epiX, epiY = args.epiY };
    if not isClient() and not isServer() and not isCoopHost() then
        RC_OnFlightNews("RC_Explosion", "FlightNews", flightDataObject);
    else
        sendServerCommand("RC_Explosion", "FlightNews", flightDataObject);
    end
end

function On_DetonationRequest(module, command, player, args)
    if module ~= "RC_Explosion" then return end
    if command ~= "DetonationRequest" then return end

    -- NEED TO FIX LONG RANGE SHOT
    local detonationSquare = getCell():getOrCreateGridSquare(args.epiX, args.epiY, args.epiZ);
    if detonationSquare then
        local zNeo = RDC_CheckZoneHasPlayer(detonationSquare);
        if zNeo then
            local detonator = RCDetonatorBox:new(detonationSquare:getX(), detonationSquare:getY(), detonationSquare:getZ(), args.rectObject, args.fuseLength, args.charges);
            detonator:activate(zNeo);
            table.insert(RDC_Z_server.detonationList, detonator);
        end
    end
end

Events.OnLoad.Add(RC_InitSandVariables);

Events.OnClientCommand.Add(On_SmokesUp);
Events.OnClientCommand.Add(On_BurnItDown);
Events.OnClientCommand.Add(On_WreckIt);
Events.OnClientCommand.Add(On_TakeOff);
Events.OnClientCommand.Add(On_HappyLanding);
Events.OnClientCommand.Add(On_DetonationRequest);